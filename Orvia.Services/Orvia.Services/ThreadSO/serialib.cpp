#include "serialib.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// serialib ////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

serialib::serialib()
{

//

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// ~serialib ///////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

serialib::~serialib()
{

    closeDevice();

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// openDevice //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

char serialib::openDevice(  const char *Device       , 
                            const unsigned int Bauds ,
                            SerialDataBits Databits  ,
                            SerialParity Parity      ,
                            SerialStopBits Stopbits)    {

#if defined (_WIN32) || defined( _WIN64)

    // Open serial port

    hSerial = CreateFileA(Device,GENERIC_READ | GENERIC_WRITE,0,0,OPEN_EXISTING,/*FILE_ATTRIBUTE_NORMAL*/0,0);

    if(hSerial==INVALID_HANDLE_VALUE) {

        if(GetLastError()==ERROR_FILE_NOT_FOUND)
            return -1; // Device not found

        // Error while opening the device
        return -2;

    }

    // Structure for the port parameters
    DCB dcbSerialParams;
    dcbSerialParams.DCBlength=sizeof(dcbSerialParams);

    // Get the port parameters
    if (!GetCommState(hSerial, &dcbSerialParams)) return -3;

    // Set the speed (Bauds)
    switch (Bauds)
    {
        case 110  :     dcbSerialParams.BaudRate=CBR_110; break;
        case 300  :     dcbSerialParams.BaudRate=CBR_300; break;
        case 600  :     dcbSerialParams.BaudRate=CBR_600; break;
        case 1200 :     dcbSerialParams.BaudRate=CBR_1200; break;
        case 2400 :     dcbSerialParams.BaudRate=CBR_2400; break;
        case 4800 :     dcbSerialParams.BaudRate=CBR_4800; break;
        case 9600 :     dcbSerialParams.BaudRate=CBR_9600; break;
        case 14400 :    dcbSerialParams.BaudRate=CBR_14400; break;
        case 19200 :    dcbSerialParams.BaudRate=CBR_19200; break;
        case 38400 :    dcbSerialParams.BaudRate=CBR_38400; break;
        case 56000 :    dcbSerialParams.BaudRate=CBR_56000; break;
        case 57600 :    dcbSerialParams.BaudRate=CBR_57600; break;
        case 115200 :   dcbSerialParams.BaudRate=CBR_115200; break;
        case 128000 :   dcbSerialParams.BaudRate=CBR_128000; break;
        case 256000 :   dcbSerialParams.BaudRate=CBR_256000; break;
        default : return -4;
    }

    //select data size
    BYTE bytesize = 0;
    switch(Databits) {
        case SERIAL_DATABITS_5: bytesize = 5; break;
        case SERIAL_DATABITS_6: bytesize = 6; break;
        case SERIAL_DATABITS_7: bytesize = 7; break;
        case SERIAL_DATABITS_8: bytesize = 8; break;
        case SERIAL_DATABITS_16: bytesize = 16; break;
        default: return -7;
    }

    BYTE stopBits = 0;

    switch(Stopbits) {
        case SERIAL_STOPBITS_1: stopBits = ONESTOPBIT; break;
        case SERIAL_STOPBITS_1_5: stopBits = ONE5STOPBITS; break;
        case SERIAL_STOPBITS_2: stopBits = TWOSTOPBITS; break;
        default: return -8;
    }

    BYTE parity = 0;

    switch(Parity) {
        case SERIAL_PARITY_NONE: parity = NOPARITY; break;
        case SERIAL_PARITY_EVEN: parity = EVENPARITY; break;
        case SERIAL_PARITY_ODD: parity = ODDPARITY; break;
        case SERIAL_PARITY_MARK: parity = MARKPARITY; break;
        case SERIAL_PARITY_SPACE: parity = SPACEPARITY; break;
        default: return -9;
    }

    // configure byte size
    dcbSerialParams.ByteSize = bytesize;
    // configure stop bits
    dcbSerialParams.StopBits = stopBits;
    // configure parity
    dcbSerialParams.Parity = parity;

    // Write the parameters
    if(!SetCommState(hSerial, &dcbSerialParams)) return -5;

    // Set the Timeout parameters
    timeouts.ReadIntervalTimeout=0;
    // No TimeOut
    timeouts.ReadTotalTimeoutConstant=MAXDWORD;
    timeouts.ReadTotalTimeoutMultiplier=0;
    timeouts.WriteTotalTimeoutConstant=MAXDWORD;
    timeouts.WriteTotalTimeoutMultiplier=0;

    // Write the parameters
    if(!SetCommTimeouts(hSerial, &timeouts)) return -6;

    // Opening successfull
    return 1;

#endif
#if defined (__linux__) || defined(__APPLE__)

    // Structure with the device's options
    struct termios options;


    // Open device
    fd = open(Device, O_RDWR | O_NOCTTY | O_NDELAY);
    // If the device is not open, return -1
    if (fd == -1) return -2;
    // Open the device in nonblocking mode
    fcntl(fd, F_SETFL, FNDELAY);


    // Get the current options of the port
    tcgetattr(fd, &options);
    // Clear all the options
    bzero(&options, sizeof(options));

    // Prepare speed (Bauds)
    speed_t         Speed;

    switch (Bauds)
    {
        case 110  :     Speed=B110; break;
        case 300  :     Speed=B300; break;
        case 600  :     Speed=B600; break;
        case 1200 :     Speed=B1200; break;
        case 2400 :     Speed=B2400; break;
        case 4800 :     Speed=B4800; break;
        case 9600 :     Speed=B9600; break;
        case 19200 :    Speed=B19200; break;
        case 38400 :    Speed=B38400; break;
        case 57600 :    Speed=B57600; break;
        case 115200 :   Speed=B115200; break;
        default : return -4;
    }

    int databits_flag = 0;

    switch(Databits) {
        case SERIAL_DATABITS_5: databits_flag = CS5; break;
        case SERIAL_DATABITS_6: databits_flag = CS6; break;
        case SERIAL_DATABITS_7: databits_flag = CS7; break;
        case SERIAL_DATABITS_8: databits_flag = CS8; break;
        //16 bits and everything else not supported
        default: return -7;
    }

    int stopbits_flag = 0;

    switch(Stopbits) {
        case SERIAL_STOPBITS_1: stopbits_flag = 0; break;
        case SERIAL_STOPBITS_2: stopbits_flag = CSTOPB; break;
        //1.5 stopbits and everything else not supported
        default: return -8;
    }

    int parity_flag = 0;

    switch(Parity) {
        case SERIAL_PARITY_NONE: parity_flag = 0; break;
        case SERIAL_PARITY_EVEN: parity_flag = PARENB; break;
        case SERIAL_PARITY_ODD: parity_flag = (PARENB | PARODD); break;
        //mark and space parity not supported
        default: return -9;
    }

    // Set the baud rate
    cfsetispeed(&options, Speed);
    cfsetospeed(&options, Speed);

    // Configure the device : data bits, stop bits, parity, no control flow
    // Ignore modem control lines (CLOCAL) and Enable receiver (CREAD)
    options.c_cflag |= ( CLOCAL | CREAD | databits_flag | parity_flag | stopbits_flag);
    options.c_iflag |= ( IGNPAR | IGNBRK );
    // Timer unused
    options.c_cc[VTIME]=0;
    // At least on character before satisfy reading
    options.c_cc[VMIN]=0;
    // Activate the settings
    tcsetattr(fd, TCSANOW, &options);

    // Success
    return (1);

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// closeDevice /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

void serialib::closeDevice()
{

#if defined (_WIN32) || defined( _WIN64)
    CloseHandle(hSerial);
#endif
#if defined (__linux__) || defined(__APPLE__)
    close (fd);
#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// writeChar ///////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

char serialib::writeChar(const char Byte)
{
#if defined (_WIN32) || defined( _WIN64)

    // Number of bytes written
    DWORD dwBytesWritten;
    // Write the char to the serial device
    // Return -1 if an error occured
    if(!WriteFile(hSerial,&Byte,1,&dwBytesWritten,NULL)) return -1;

    // Write operation successfull
    return 1;

#endif
#if defined (__linux__) || defined(__APPLE__)

    // Write the char
    if (write(fd,&Byte,1)!=1) return -1;

    // Write operation successfull
    return 1;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// writeString /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

char serialib::writeString(const char *receivedString)
{

#if defined (_WIN32) || defined( _WIN64)

    // Number of bytes written
    DWORD dwBytesWritten;
    // Write the string
    if(!WriteFile(hSerial,receivedString,strlen(receivedString),&dwBytesWritten,NULL))
        // Error while writing, return -1
        return -1;
    // Write operation successfull
    return 1;

#endif
#if defined (__linux__) || defined(__APPLE__)

    // Lenght of the string
    int Lenght=strlen(receivedString);
    // Write the string
    if (write(fd,receivedString,Lenght)!=Lenght) return -1;

    // Write operation successfull
    return 1;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// writeBytes //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

char serialib::writeBytes(const void *Buffer, const unsigned int NbBytes)
{

#if defined (_WIN32) || defined( _WIN64)

    // Number of bytes written
    DWORD dwBytesWritten;
    // Write data
    if(!WriteFile(hSerial, Buffer, NbBytes, &dwBytesWritten, NULL))
        // Error while writing, return -1
        return -1;

    // Write operation successfull
    return 1;

#endif
#if defined (__linux__) || defined(__APPLE__)

    // Write data
    if (write (fd,Buffer,NbBytes)!=(ssize_t)NbBytes) return -1;

    // Write operation successfull
    return 1;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// readChar ////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

char serialib::readChar(char *pByte,unsigned int timeOut_ms)
{

#if defined (_WIN32) || defined(_WIN64)

    // Number of bytes read
    DWORD dwBytesRead = 0;

    // Set the TimeOut
    timeouts.ReadTotalTimeoutConstant=timeOut_ms;

    // Write the parameters, return -1 if an error occured
    if(!SetCommTimeouts(hSerial, &timeouts)) return -1;

    // Read the byte, return -2 if an error occured
    if(!ReadFile(hSerial,pByte, 1, &dwBytesRead, NULL)) return -2;

    // Return 0 if the timeout is reached
    if (dwBytesRead==0) return 0;

    // The byte is read
    return 1;

#endif
#if defined (__linux__) || defined(__APPLE__)

    // Timer used for timeout
    timeOut         timer;
    // Initialise the timer
    timer.initTimer();
    // While Timeout is not reached
    while (timer.elapsedTime_ms()<timeOut_ms || timeOut_ms==0)
    {
        // Try to read a byte on the device
        switch (read(fd,pByte,1)) {
        case 1  : return 1; // Read successfull
        case -1 : return -2; // Error while reading
        }
    }

    return 0;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// readStringNoTimeOut /////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

int serialib::readStringNoTimeOut(char *receivedString,char finalChar,unsigned int maxNbBytes)
{

    // Number of characters read
    unsigned int    NbBytes=0;
    // Returned value from Read
    char            charRead;

    // While the buffer is not full
    while (NbBytes<maxNbBytes)
    {
        // Read a character with the restant time
        charRead=readChar(&receivedString[NbBytes]);

        // Check a character has been read
        if (charRead==1)
        {

            // Check if this is the final char
            if (receivedString[NbBytes]==finalChar)
            {
                // This is the final char, add zero (end of string)
                receivedString  [++NbBytes]=0;
                // Return the number of bytes read
                return NbBytes;
            }

            // The character is not the final char, increase the number of bytes read
            NbBytes++;

        }

        // An error occured while reading, return the error number
        if (charRead<0) return charRead;

    }

    // Buffer is full : return -3
    return -3;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// readString //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

int serialib::readString(char *receivedString,char finalChar,unsigned int maxNbBytes,unsigned int timeOut_ms)
{

    // Check if timeout is requested
    if (timeOut_ms==0) return readStringNoTimeOut(receivedString,finalChar,maxNbBytes);

    // Number of bytes read
    unsigned int    nbBytes=0;
    // Character read on serial device
    char            charRead;
    // Timer used for timeout
    timeOut         timer;
    long int        timeOutParam;

    // Initialize the timer (for timeout)
    timer.initTimer();

    // While the buffer is not full
    while (nbBytes<maxNbBytes)
    {

        // Compute the TimeOut for the next call of ReadChar
        timeOutParam = timeOut_ms-timer.elapsedTime_ms();

        // If there is time remaining
        if (timeOutParam>0)
        {

            // Wait for a byte on the serial link with the remaining time as timeout
            charRead=readChar(&receivedString[nbBytes],timeOutParam);

            // If a byte has been received
            if (charRead==1)
            {

                // Check if the character received is the final one
                if (receivedString[nbBytes]==finalChar)
                {

                    // Final character: add the end character 0
                    receivedString  [++nbBytes]=0;
                    // Return the number of bytes read
                    return nbBytes;

                }
                // This is not the final character, just increase the number of bytes read
                nbBytes++;

            }
            // Check if an error occured during reading char
            // If an error occurend, return the error number
            if (charRead<0) return charRead;

        }
        // Check if timeout is reached
        if (timer.elapsedTime_ms()>timeOut_ms)
        {

            // Add the end caracter
            receivedString[nbBytes]=0;
            // Return 0 (timeout reached)
            return 0;

        }

    }

    // Buffer is full : return -3
    return -3;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// readBytes ///////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

int serialib::readBytes(void *buffer,unsigned int maxNbBytes,unsigned int timeOut_ms, unsigned int sleepDuration_us)
{

#if defined (_WIN32) || defined(_WIN64)

    // Avoid warning while compiling
    UNUSED(sleepDuration_us);

    // Number of bytes read
    DWORD dwBytesRead = 0;

    // Set the TimeOut
    timeouts.ReadTotalTimeoutConstant=(DWORD)timeOut_ms;

    // Write the parameters and return -1 if an error occrured
    if(!SetCommTimeouts(hSerial, &timeouts)) return -1;


    // Read the bytes from the serial device, return -2 if an error occured
    if(!ReadFile(hSerial,buffer,(DWORD)maxNbBytes,&dwBytesRead, NULL))  return -2;

    // Return the byte read
    return dwBytesRead;

#endif
#if defined (__linux__) || defined(__APPLE__)

    // Timer used for timeout
    timeOut          timer;
    // Initialise the timer
    timer.initTimer();
    unsigned int     NbByteRead=0;
    // While Timeout is not reached
    while (timer.elapsedTime_ms()<timeOut_ms || timeOut_ms==0)
    {

        // Compute the position of the current byte
        unsigned char* Ptr=(unsigned char*)buffer+NbByteRead;
        // Try to read a byte on the device
        int Ret=read(fd,(void*)Ptr,maxNbBytes-NbByteRead);
        // Error while reading
        if (Ret==-1) return -2;

        // One or several byte(s) has been read on the device
        if (Ret>0)
        {

            // Increase the number of read bytes
            NbByteRead+=Ret;
            // Success : bytes has been read
            if (NbByteRead>=maxNbBytes)
                return NbByteRead;

        }
        // Suspend the loop to avoid charging the CPU
        usleep (sleepDuration_us);

    }

    // Timeout reached, return the number of bytes read
    return NbByteRead;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// flushReceiver ///////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

char serialib::flushReceiver()
{

#if defined (_WIN32) || defined(_WIN64)

    // Purge receiver
    return PurgeComm (hSerial, PURGE_RXCLEAR);

#endif
#if defined (__linux__) || defined(__APPLE__)

    // Purge receiver
    tcflush(fd,TCIFLUSH);

    return true;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// available ///////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

int serialib::available()
{    

#if defined (_WIN32) || defined(_WIN64)

    // Device errors
    DWORD commErrors;
    // Device status
    COMSTAT commStatus;
    // Read status
    ClearCommError(hSerial, &commErrors, &commStatus);

    // Return the number of pending bytes
    return commStatus.cbInQue;

#endif
#if defined (__linux__) || defined(__APPLE__)

    int nBytes=0;
    // Return number of pending bytes in the receiver
    ioctl(fd, FIONREAD, &nBytes);

    return nBytes;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// DTR /////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool serialib::DTR(bool status)
{

    if (status)
        // Set DTR
        return this->setDTR();
    else
        // Unset DTR
        return this->clearDTR();

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// setDTR //////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool serialib::setDTR()
{

#if defined (__linux__) || defined(__APPLE__)

    // Set DTR
    int status_DTR=0;
    ioctl(fd, TIOCMGET, &status_DTR);
    status_DTR |= TIOCM_DTR;
    ioctl(fd, TIOCMSET, &status_DTR);

    return true;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// clearDTR ////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool serialib::clearDTR()
{

#if defined (__linux__) || defined(__APPLE__)

    // Clear DTR
    int status_DTR=0;
    ioctl(fd, TIOCMGET, &status_DTR);
    status_DTR &= ~TIOCM_DTR;
    ioctl(fd, TIOCMSET, &status_DTR);

    return true;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// RTS /////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool serialib::RTS(bool status)
{

    if (status)
        // Set RTS
        return this->setRTS();
    else
        // Unset RTS
        return this->clearRTS();

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// setRTS //////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool serialib::setRTS()
{

#if defined (__linux__) || defined(__APPLE__)

    // Set RTS
    int status_RTS=0;
    ioctl(fd, TIOCMGET, &status_RTS);
    status_RTS |= TIOCM_RTS;
    ioctl(fd, TIOCMSET, &status_RTS);

    return true;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// clearRTS ////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool serialib::clearRTS()
{

#if defined (__linux__) || defined(__APPLE__)

    // Clear RTS
    int status_RTS=0;
    ioctl(fd, TIOCMGET, &status_RTS);
    status_RTS &= ~TIOCM_RTS;
    ioctl(fd, TIOCMSET, &status_RTS);

    return true;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// isCTS ///////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool serialib::isCTS()
{
#if defined (_WIN32) || defined(_WIN64)

    DWORD modemStat;
    GetCommModemStatus(hSerial, &modemStat);

    return modemStat & MS_CTS_ON;

#endif
#if defined (__linux__) || defined(__APPLE__)

    int status=0;
    //Get the current status of the CTS bit
    ioctl(fd, TIOCMGET, &status);

    return status & TIOCM_CTS;

#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// isDSR ///////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool serialib::isDSR()
{

#if defined (_WIN32) || defined(_WIN64)

    DWORD modemStat;
    GetCommModemStatus(hSerial, &modemStat);

    return modemStat & MS_DSR_ON;

#endif
#if defined (__linux__) || defined(__APPLE__)

    int status=0;
    //Get the current status of the DSR bit
    ioctl(fd, TIOCMGET, &status);

    return status & TIOCM_DSR;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// isDCD ///////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool serialib::isDCD()
{

#if defined (_WIN32) || defined(_WIN64)

    DWORD modemStat;
    GetCommModemStatus(hSerial, &modemStat);

    return modemStat & MS_RLSD_ON;

#endif
#if defined (__linux__) || defined(__APPLE__)

    int status=0;
    //Get the current status of the DCD bit
    ioctl(fd, TIOCMGET, &status);

    return status & TIOCM_CAR;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// isRI ////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool serialib::isRI()
{

#if defined (_WIN32) || defined(_WIN64)

    DWORD modemStat;
    GetCommModemStatus(hSerial, &modemStat);

    return modemStat & MS_RING_ON;

#endif
#if defined (__linux__) || defined(__APPLE__)

    int status=0;
    //Get the current status of the RING bit
    ioctl(fd, TIOCMGET, &status);

    return status & TIOCM_RNG;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// isDTR ///////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool serialib::isDTR()
{

#if defined (_WIN32) || defined( _WIN64)
    return currentStateDTR;
#endif
#if defined (__linux__) || defined(__APPLE__)

    int status=0;
    //Get the current status of the DTR bit
    ioctl(fd, TIOCMGET, &status);

    return status & TIOCM_DTR  ;

#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// isRTS ///////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool serialib::isRTS()
{

#if defined (__linux__) || defined(__APPLE__)

    int status=0;
    //Get the current status of the CTS bit
    ioctl(fd, TIOCMGET, &status);

    return status & TIOCM_RTS;

#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////




// **********************************************************************************************************
//  Class timeOut
// **********************************************************************************************************

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// timeOut /////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

timeOut::timeOut()
{}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// initTimer ///////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

void timeOut::initTimer()
{

    gettimeofday(&previousTime, NULL);

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// elapsedTime_ms //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

unsigned long int timeOut::elapsedTime_ms()
{

    // Current time
    struct timeval CurrentTime;
    // Number of seconds and microseconds since last call
    int sec,usec;

    // Get current time
    gettimeofday(&CurrentTime, NULL);

    // Compute the number of seconds and microseconds elapsed since last call
    sec=CurrentTime.tv_sec-previousTime.tv_sec;
    usec=CurrentTime.tv_usec-previousTime.tv_usec;

    // If the previous usec is higher than the current one
    if (usec<0)
    {
        // Recompute the microseonds and substract one second
        usec=1000000-previousTime.tv_usec+CurrentTime.tv_usec;
        sec--;
    }

    // Return the elapsed time in milliseconds
    return sec*1000+usec/1000;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
